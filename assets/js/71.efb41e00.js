(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{427:function(e,n,t){"use strict";t.r(n);var a=t(26),i=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Fyrox is an "),n("a",{attrs:{href:"https://github.com/FyroxEngine/Fyrox",target:"_blank",rel:"noopener noreferrer"}},[e._v("open-source"),n("OutboundLink")],1),e._v(" Rust game engine with lots of out-of-box\ngame-ready features and a full-featured editor. Changes of this week was mostly focused on animation system\nimprovements.")]),e._v(" "),n("h2",{attrs:{id:"blend-space"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blend-space"}},[e._v("#")]),e._v(" Blend Space")]),e._v(" "),n("p",[n("img",{attrs:{src:"/assets/twif15/blend_space.gif",alt:"blend space"}})]),e._v(" "),n("p",[e._v("Blend space is an animation blending technique which allows you to blend multiple animations into one based\non two numeric input parameters (sampling point). Blend space consists of any number of points, located in\nthe value space; these points are triangulated:")]),e._v(" "),n("p",[n("img",{attrs:{src:"/assets/twif15/blend_space.png",alt:"blend space 2"}})]),e._v(" "),n("p",[e._v("To blend animation, you need to pass sampling point in (visualized as a crosshair on the screenshot) and\nthe blend space will calculate weights for three animation poses around the sampling point. See the gif\nabove to get better understanding.")]),e._v(" "),n("p",[e._v("Where this technique is used? In pretty much any relatively complex modern game. It is used mainly to\nblend locomotion animations based on two parameters: speed and direction. For example, on the X axis you\ncan have direction angle and on Y axis - speed. Then you put desired animations on the blend space, and\nit will blend everything accordingly to speed and direction: if a character moves fast, then running\nanimation will prevail, if it needs to run left - direction will be -1 and running left animation will\nprevail and so on. It is a very powerful and flexible technique, that helps achieving naturally looking\nanimations on most conditions.")]),e._v(" "),n("h2",{attrs:{id:"book-improvements"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#book-improvements"}},[e._v("#")]),e._v(" Book Improvements")]),e._v(" "),n("p",[e._v("The book is slowly, but surely getting improvements. 7 sections were proofread and improved with more info.")]),e._v(" "),n("h2",{attrs:{id:"other"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#other"}},[e._v("#")]),e._v(" Other")]),e._v(" "),n("p",[e._v("It is now possible to show/hide debug shapes (for lights, cameras, etc.) in the editor.")]),e._v(" "),n("h2",{attrs:{id:"full-list-of-changes-in-random-order"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#full-list-of-changes-in-random-order"}},[e._v("#")]),e._v(" Full List of Changes in Random Order")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Added blend space.")])]),e._v(" "),n("li",[n("p",[e._v("Added blend space editor in the ABSM editor.")])]),e._v(" "),n("li",[n("p",[e._v("Ability to enable/disable debug geometry in the editor.")])]),e._v(" "),n("li",[n("p",[e._v("Various book improvements.")])]),e._v(" "),n("li",[n("p",[e._v("Implement Reflect for RefCell<T> + Rc<RefCell<T>>")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);