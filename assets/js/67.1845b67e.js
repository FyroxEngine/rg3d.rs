(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{421:function(e,t,i){"use strict";i.r(t);var r=i(26),o=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Fyrox is an "),t("a",{attrs:{href:"https://github.com/FyroxEngine/Fyrox",target:"_blank",rel:"noopener noreferrer"}},[e._v("open-source"),t("OutboundLink")],1),e._v(" Rust game engine with lots of out-of-box\ngame-ready features and a full-featured editor. This week was mostly dedicated to adding some new features\nand fixing existing functionality.")]),e._v(" "),t("h2",{attrs:{id:"reflection-refactoring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reflection-refactoring"}},[e._v("#")]),e._v(" Reflection Refactoring")]),e._v(" "),t("p",[e._v('Main downside of the current reflection system in the engine is that it does not support reflection of types\nwith interior mutability. You simply cannot "inspect" fields of a struct/enum of type with interior mutability\n(such as '),t("code",[e._v("Mutex<T>")]),e._v(", "),t("code",[e._v("RwLock<T>")]),e._v(", "),t("code",[e._v("RefCell<T>")]),e._v(", "),t("code",[e._v("Arc<Mutex<T>>")]),e._v(", etc.), because anything that is located\ninside these types require to hold some kind of lock while accessing internals ("),t("code",[e._v("MutexGuard<T>")]),e._v(" in case of\n"),t("code",[e._v("Mutex")]),e._v(", "),t("code",[e._v("Ref<T>/RefMut<T>")]),e._v(" in case of "),t("code",[e._v("RefCell")]),e._v(" and so on).\n"),t("a",{attrs:{href:"https://github.com/FyroxEngine/Fyrox/blob/master/fyrox-core/src/reflect.rs#L150",target:"_blank",rel:"noopener noreferrer"}},[e._v("Current API"),t("OutboundLink")],1),e._v(" has lots of\nmethods that returns references and such API structure is incompatible with types with interior mutability,\nbecause it does not allow you to hold a lock while accessing internals.")]),e._v(" "),t("p",[e._v("Interior mutability support in reflection system is crucial for animation system of the engine. Its main\nusage is to animate numeric parameters of renderer materials. This ability allows you change shader uniforms\nvia standard animation pipeline.")]),e._v(" "),t("p",[e._v("Initial support for interior mutability "),t("a",{attrs:{href:"https://github.com/FyroxEngine/Fyrox/pull/422",target:"_blank",rel:"noopener noreferrer"}},[e._v("was added"),t("OutboundLink")],1),e._v(", it is\npretty big and breaking change, so it will require some additional testing before merging. The API of "),t("code",[e._v("Reflect")]),e._v("\ntrait was changed "),t("a",{attrs:{href:"https://github.com/FyroxEngine/Fyrox/blob/reflection_refactoring/fyrox-core/src/reflect.rs#L154",target:"_blank",rel:"noopener noreferrer"}},[e._v("completely"),t("OutboundLink")],1),e._v(".\nNow, instead of returning references immediately, every function that previously returned references now has\nadditional parameter. This parameter is a reference to a closure that allows you to do something with a reference\nto inner value. Such approach allows to hold mutex lock (and analogues) while doing something with data.")]),e._v(" "),t("h2",{attrs:{id:"determinism-for-particle-systems"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#determinism-for-particle-systems"}},[e._v("#")]),e._v(" Determinism for Particle Systems")]),e._v(" "),t("p",[e._v("Previously, particle systems used global pseudo-random numbers generator (PRNG), which resulted in non-deterministic\nbehavior. Now, each instance of particle system has its own PRNG and saves its seed, which makes behaviour of\nparticle systems deterministic. It is even possible to rewind particle systems to a particle time and the result\nwill always be the same (until PRNG implementation is not changed).")]),e._v(" "),t("h2",{attrs:{id:"color-gradient-editor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#color-gradient-editor"}},[e._v("#")]),e._v(" Color Gradient Editor")]),e._v(" "),t("p",[e._v("For a long time there was no property editor for "),t("code",[e._v("Color Over Lifetime")]),e._v(" field of particle systems. The type of this\nfield is "),t("code",[e._v("ColorGradient")]),e._v(" which allows you to define a set of color points and fetch intermediate values at any\nposition at the gradient. Now, the editor has property editor for "),t("code",[e._v("ColorGradient")]),e._v(" and it works like so:")]),e._v(" "),t("YtVideo",{attrs:{url:"https://www.youtube.com/embed/EkzDiCpvdhM"}}),e._v(" "),t("h2",{attrs:{id:"other"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#other"}},[e._v("#")]),e._v(" Other")]),e._v(" "),t("p",[e._v("It is now possible to rewind particle systems during preview mode - it removes all generated particles\nand starts generation over.")]),e._v(" "),t("p",[e._v("Engine's performance statistics now correctly show the time spent in scripts and plugins, allowing you to measure\nperformance of your game.")]),e._v(" "),t("p",[e._v("Previously, ABSM editor had a bug where activation of a state/transition on one layer was shown on the layer being\nedited, causing confusion while debugging ABSMs.")]),e._v(" "),t("h2",{attrs:{id:"full-list-of-changes-in-random-order"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#full-list-of-changes-in-random-order"}},[e._v("#")]),e._v(" Full List of Changes in Random Order")]),e._v(" "),t("ul",[t("li",[e._v("Reflection system refactoring to support types with interior mutability.")]),e._v(" "),t("li",[e._v("Compound conditions (computational graph) for ABSM transitions.")]),e._v(" "),t("li",[e._v("Fixed incorrect activation of transition/states during preview mode in ABSM editor.")]),e._v(" "),t("li",[e._v("Improved "),t("code",[e._v("ColorGradient")]),e._v(" API.")]),e._v(" "),t("li",[e._v("Simplified "),t("code",[e._v("color_over_lifetime")]),e._v(" field usage in particle systems (breaking change).")]),e._v(" "),t("li",[e._v("Property editor for "),t("code",[e._v("ColorGradient")])]),e._v(" "),t("li",[e._v("Improved engine's performance statistics.")]),e._v(" "),t("li",[e._v("Fixed rare panic in "),t("code",[e._v("FormattedText")]),e._v(".")]),e._v(" "),t("li",[e._v("Fixed "),t("code",[e._v("ParticleSystem::clear_particles")]),e._v(" - it was working incorrectly with emitters that have\n"),t("code",[e._v("resurrect_particles == false")])]),e._v(" "),t("li",[e._v('Ability to "rewind" particle systems in particle system control panel.')]),e._v(" "),t("li",[e._v("Fixed preview mode for particle systems.")]),e._v(" "),t("li",[e._v("Determinism for particle systems.")]),e._v(" "),t("li",[e._v("Ability to rewind particle systems to a particular time.")])])],1)}),[],!1,null,null,null);t.default=o.exports}}]);